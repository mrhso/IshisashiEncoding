# UTF-8 系列

## 所收编码
### 实际存在
- [UTF-8](https://www.unicode.org/versions/Unicode10.0.0/ch03.pdf#G31703)
- [CESU-8](https://www.unicode.org/reports/tr26/)
- [MUTF-8](https://docs.oracle.com/javase/8/docs/api/java/io/DataInput.html#modified-utf-8)
- [WTF-8](https://simonsapin.github.io/wtf-8/)

## 解说
UTF-8 兼容 ASCII，曾在 Unicode 1.1 中叫作 [FSS-UTF](https://www.unicode.org/versions/Unicode1.1.0/appF.pdf)。可以不加 BOM「0xEFBBBF」，也有常常加的情形。

CESU-8 基本同 UTF-8，但将 non-BMP 以 UTF-16 代理对表示。

MUTF-8 也基本同 CESU-8，但是将 U+0000 表示成「0xC080」。

WTF-8 启用了 0xEDA080~0xEDBFBF。

## 字节结构
以下码位数统计剔除过剩码位。

UTF-8 如下：

|字节数|第一字节|第二字节|第三字节|第四字节|码位数|注释|
|-|-|-|-|-|-|-|
|单字节|0x00~0x7F||||128||
|双字节|0xC2~0xDF|0x80~0xBF|||1920|0xC0~0xC1 属于过剩码位。|
|三字节|0xE0~0xEF|0x80~0xBF|0x80~0xBF||61440|0xEDA080~0xEDBFBF 通常不认为是合法码位。|
|四字节|0xF0~0xF4|0x80~0xBF|0x80~0xBF|0x80~0xBF|1048576||

CESU-8 如下：

|字节数|第一字节|第二字节|第三字节|第四字节|第五字节|第六字节|码位数|注释|
|-|-|-|-|-|-|-|-|-|
|单字节|0x00~0x7F||||||128||
|双字节|0xC2~0xDF|0x80~0xBF|||||1920||
|三字节|0xE0~0xEF|0x80~0xBF|0x80~0xBF||||61440|0xEDA080~0xEDBFBF 留给 non-BMP。|
|六字节|0xED|0xA0~0xAF|0x80~0xBF|0xED|0xB0~0xBF|0x80~0xBF|1048576|以 UTF-16 代理对表示 non-BMP。|

MUTF-8 如下：

|字节数|第一字节|第二字节|第三字节|第四字节|第五字节|第六字节|码位数|注释|
|-|-|-|-|-|-|-|-|-|
|单字节|0x01~0x7F||||||127||
|双字节|0xC0, 0xC2~0xDF|0x80~0xBF|||||1921|使用 0xC080 表示 U+0000。|
|三字节|0xE0~0xEF|0x80~0xBF|0x80~0xBF||||61440||
|六字节|0xED|0xA0~0xAF|0x80~0xBF|0xED|0xB0~0xBF|0x80~0xBF|1048576||

WTF-8 如下：

|字节数|第一字节|第二字节|第三字节|第四字节|码位数|注释|
|-|-|-|-|-|-|-|
|单字节|0x00~0x7F||||128||
|双字节|0xC2~0xDF|0x80~0xBF|||1920||
|三字节|0xE0~0xEF|0x80~0xBF|0x80~0xBF||63488|0xEDA080~0xEDBFBF 被启用。|
|四字节|0xF0~0xF4|0x80~0xBF|0x80~0xBF|0x80~0xBF|1048576||

## 与 Unicode 的对应关系（UTF-8）
### U+0000~U+007F
直接表示成单字节。

### U+0080~U+07FF 的转换公式
先将 Unicode Code Point 存储为双字节。

这时的结构为：
- 00000aaa
- aabbbbbb

（a 和 b 分别代表一组二进制串）

将其代入此结构，形成双字节：
- 110aaaaa
- 10bbbbbb

拆开来看，就可以这么理解：

先将 Unicode Code Point 记作 U。

将 U 除以 64，取出商和余数，分别记作 a₁ 和 b₁。（即：0xBF-0x80+1=64，也就相当于把二进制的后面 6 位和前面分离了）

则两个字节分别是：
- a₁+0xC0（即：a₁ 表示是第几次 64 循环）
- b₁+0x80（即：b₃ 表示 64 循环后的第几个）

由此就得到 U+0000~U+007F 的 UTF-8。

### U+0800~U+FFFF 的转换公式
先将 Unicode Code Point 存储为双字节。

这时的结构为：
- aaaabbbb
- bbcccccc

将其代入此结构，形成三字节：
- 1110aaaa
- 10bbbbbb
- 10cccccc

拆开来看，就可以这么理解：

先将 Unicode Code Point 记作 U。

将 U 除以 4096，取出商和余数，分别记作 a₁ 和 b₁。（即：(0xBF-0x80+1)(0xBF-0x80+1)=4096，也就相当于把二进制的后面 12 位和前面分离了）

将 b₁ 除以 64，取出商和余数，分别记作 a₂ 和 b₂。（即：0xBF-0x80+1=64，也就相当于把二进制的后面 6 位和前面分离了）

则三个字节分别是：
- a₁+0xE0（即：a₁ 表示是第几次 4096 循环）
- a₂+0x80（即：a₂ 表示是第几次 64 循环）
- b₂+0x80（即：b₃ 表示 64 循环后的第几个）

由此就得到 U+0800~U+FFFF 的 UTF-8。

### non-BMP（以及废案 U+110000~U+1FFFFF）的转换公式
先将 Unicode Code Point 存储为三字节。

这时的结构为：
- 000aaabb
- bbbbcccc
- ccdddddd

将其代入此结构，形成四字节：
- 11110aaa
- 10bbbbbb
- 10cccccc
- 10dddddd

拆开来看，就可以这么理解：

先将 Unicode Code Point 记作 U。

将 U 除以 262144，取出商和余数，分别记作 a₁ 和 b₁。（即：(0xBF-0x80+1)(0xBF-0x80+1)(0xBF-0x80+1)=262144，也就相当于把二进制的后面 18 位和前面分离了）

将 b₁ 除以 4096，取出商和余数，分别记作 a₂ 和 b₂。（即：(0xBF-0x80+1)(0xBF-0x80+1)=4096，也就相当于把二进制的后面 12 位和前面分离了）

将 b₂ 除以 64，取出商和余数，分别记作 a₃ 和 b₃。（即：0xBF-0x80+1=64，也就相当于把二进制的后面 6 位和前面分离了）

则四个字节分别是：
- a₁+0xF0（即：a₁ 表示是第几次 262144 循环）
- a₂+0x80（即：a₂ 表示是第几次 4096 循环）
- a₃+0x80（即：a₂ 表示是第几次 64 循环）
- b₃+0x80（即：b₃ 表示 64 循环后的第几个）

由此就得到 non-BMP（以及废案 U+110000~U+1FFFFF）的 UTF-8。

### 废案：U+200000~U+3FFFFFF
先将 Unicode Code Point 存储为四字节。

这时的结构为：
- 000000aa
- bbbbbbcc
- ccccdddd
- ddeeeeee

将其代入此结构，形成五字节：
- 111110aa
- 10bbbbbb
- 10cccccc
- 10dddddd
- 10eeeeee

拆开来看，就可以这么理解：

先将 Unicode Code Point 记作 U。

将 U 除以 16777216，取出商和余数，分别记作 a₁ 和 b₁。（即：(0xBF-0x80+1)(0xBF-0x80+1)(0xBF-0x80+1)(0xBF-0x80+1)=16777216，也就相当于把二进制的后面 24 位和前面分离了）

将 b₁ 除以 262144，取出商和余数，分别记作 a₂ 和 b₂。（即：(0xBF-0x80+1)(0xBF-0x80+1)(0xBF-0x80+1)=262144，也就相当于把二进制的后面 18 位和前面分离了）

将 b₂ 除以 4096，取出商和余数，分别记作 a₃ 和 b₃。（即：(0xBF-0x80+1)(0xBF-0x80+1)=4096，也就相当于把二进制的后面 12 位和前面分离了）

将 b₃ 除以 64，取出商和余数，分别记作 a₄ 和 b₄。（即：0xBF-0x80+1=64，也就相当于把二进制的后面 6 位和前面分离了）

则五个字节分别是：
- a₁+0xF8（即：a₁ 表示是第几次 16777216 循环）
- a₂+0x80（即：a₂ 表示是第几次 262144 循环）
- a₃+0x80（即：a₂ 表示是第几次 4096 循环）
- a₄+0x80（即：a₂ 表示是第几次 64 循环）
- b₄+0x80（即：b₃ 表示 64 循环后的第几个）

由此就得到 U+200000~U+3FFFFFF 的 UTF-8。

### 废案：U+4000000~U+7FFFFFFF
先将 Unicode Code Point 存储为四字节。

这时的结构为：
- 0abbbbbb
- ccccccdd
- ddddeeee
- eeffffff

将其代入此结构，形成六字节：
- 1111110a
- 10bbbbbb
- 10cccccc
- 10dddddd
- 10eeeeee
- 10ffffff

拆开来看，就可以这么理解：

先将 Unicode Code Point 记作 U。

将 U 除以 1073741824，取出商和余数，分别记作 a₁ 和 b₁。（即：(0xBF-0x80+1)(0xBF-0x80+1)(0xBF-0x80+1)(0xBF-0x80+1)(0xBF-0x80+1)=1073741824，也就相当于把二进制的后面 30 位和前面分离了）

将 b₁ 除以 16777216，取出商和余数，分别记作 a₂ 和 b₂。（即：(0xBF-0x80+1)(0xBF-0x80+1)(0xBF-0x80+1)(0xBF-0x80+1)=16777216，也就相当于把二进制的后面 24 位和前面分离了）

将 b₂ 除以 262144，取出商和余数，分别记作 a₃ 和 b₃。（即：(0xBF-0x80+1)(0xBF-0x80+1)(0xBF-0x80+1)=262144，也就相当于把二进制的后面 18 位和前面分离了）

将 b₃ 除以 4096，取出商和余数，分别记作 a₄ 和 b₄。（即：(0xBF-0x80+1)(0xBF-0x80+1)=4096，也就相当于把二进制的后面 12 位和前面分离了）

将 b₄ 除以 64，取出商和余数，分别记作 a₅ 和 b₅。（即：0xBF-0x80+1=64，也就相当于把二进制的后面 6 位和前面分离了）

则六个字节分别是：
- a₁+0xFC（即：a₁ 表示是第几次 1073741824 循环）
- a₂+0x80（即：a₂ 表示是第几次 16777216 循环）
- a₃+0x80（即：a₂ 表示是第几次 262144 循环）
- a₄+0x80（即：a₂ 表示是第几次 4096 循环）
- a₅+0x80（即：a₂ 表示是第几次 64 循环）
- b₅+0x80（即：b₃ 表示 64 循环后的第几个）

由此就得到 U+4000000~U+7FFFFFFF 的 UTF-8。

### U+D800~U+DFFF
这一块不会定义任何字符，都拿来给 UTF-16 表示 non-BMP。

如果启用这一块，那这被叫作 WTF-8。

## 与 Unicode 的对应关系（CESU-8）
基本同 UTF-8 一致，但是 non-BMP 使用 UTF-16 代理对表示。

详见 [UTF-16](https://github.com/mrhso/IshisashiEncoding/blob/master/UTF/UTF-16/README.md#non-bmp-的转换公式)。

## 与 Unicode 的对应关系（MUTF-8）
基本同 CESU-8 一致，但是 U+0000 表示成「0xC080」。
